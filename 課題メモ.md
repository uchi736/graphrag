# Graph RAG 課題メモ

## 課題1: 無関係な関係が検索結果に含まれる問題

### 発生日時
2025-12-05

### 問題の詳細

**質問例**: 「桃太郎を倒したのは誰？」

**期待される結果**:
```
鬼 -[DEFEATS]→ 桃太郎
鬼 -[FIGHTS]→ 桃太郎
桃太郎 -[SURRENDERS_TO]→ 鬼
```

**実際の結果（問題あり）**:
```
村 -[LIVES_IN]→ おばあさん  ← 無関係
村 -[LIVES_IN]→ おじいさん  ← 無関係
桃太郎 -[RETURNS_TO]→ 村
鬼 -[DEFEATS]→ 桃太郎
...
```

### 原因分析

#### 1. **無向トラバーサルの問題**

**問題のあるCypherクエリ**:
```cypher
MATCH path = (start_node)-[*1..2]-(connected_node)
```

- `-[*1..2]-` は**無向パス**として解釈される
- 順方向・逆方向の両方にマッチ

**処理フロー**:
1. 質問「桃太郎を倒したのは誰？」
2. エンティティ抽出: `["桃太郎"]`
3. 桃太郎ノードを起点に2-hop無向探索
4. **1-hop**: `桃太郎 -[RETURNS_TO]→ 村`
5. **2-hop**: `村 ←[LIVES_IN]- おばあさん` （**逆向き**でもマッチ）
6. 結果に `村 -[LIVES_IN]→ おばあさん` が含まれる ❌

#### 2. **質問の意図が考慮されていない**

- 質問の意図: 「桃太郎を**倒した**エンティティ」（敵対関係）
- 現在のロジック: 「桃太郎に関連するすべての2-hop以内の関係」
- 関係タイプ（`FIGHTS`, `DEFEATS`等）のフィルタリングなし

#### 3. **グラフの方向性の無視**

以下のような矛盾した関係が両方取得される:
```
鬼 -[DEFEATS]→ 桃太郎      ← 鬼が桃太郎を倒した
桃太郎 -[SURRENDERS_TO]→ 鬼 ← 桃太郎が鬼に降伏
鬼 -[SURRENDERS_TO]→ 桃太郎  ← 矛盾！（逆向きパスから生成）
```

---

## 解決策

### Phase 1: 有向トラバーサルへの変更 ✅ **実装済み**

**変更内容**:
```cypher
変更前: MATCH path = (start_node)-[*1..2]-(connected_node)
変更後: MATCH path = (start_node)-[*1..2]->(connected_node)
```

**修正箇所**:
- [app.py:218](app.py#L218) - `restore_from_existing_graph` 内
- [app.py:438](app.py#L438) - `create_rag_chain` 内

**期待される効果**:
- 逆向き関係の除外
- `村 -[LIVES_IN]→ おばあさん` は取得されない（桃太郎から村への経路はあるが、村からおばあさんへの逆向きパスは除外）

**変更前の結果例**:
```
桃太郎を起点とした2-hop:
桃太郎 → 村 → (終了、村から出る関係なし)
桃太郎 ← 村 ← おばあさん (逆向きパス) ❌
→ 結果: 村 -[LIVES_IN]→ おばあさん
```

**変更後の結果例**:
```
桃太郎を起点とした2-hop（有向）:
桃太郎 → 村 → (終了)
桃太郎 → 鬼 → 宝物
→ 結果: 村 -[LIVES_IN]→ おばあさん は除外 ✅
```

---

## 今後の改善案

### Phase 2: 質問タイプの検出とホップ数の調整

**実装案**:
```python
def detect_question_type(question: str) -> dict:
    """質問タイプを検出してパラメータを返す"""
    if "誰が" in question or "何が" in question:
        return {"hops": "1", "direction": "incoming"}  # 主語を求める
    elif "どこ" in question or "いつ" in question:
        return {"hops": "1..2", "direction": "outgoing"}
    else:
        return {"hops": "1..2", "direction": "outgoing"}
```

### Phase 3: 関係タイプの抽出とフィルタリング

**実装案**:
```python
def extract_relation_types(question: str) -> List[str]:
    """質問から関連する関係タイプを抽出"""
    keyword_to_relations = {
        "倒": ["DEFEATS", "FIGHTS", "SURRENDERS_TO"],
        "住": ["LIVES_IN", "STAYS_IN"],
        "仲間": ["BECOMES_COMPANION_OF", "RECRUITS", "JOINS"],
        "与": ["GIVES", "GIVES_TO", "RECEIVES"]
    }
    # LLMで抽出するか、キーワードマッチング
```

Cypherクエリ:
```cypher
WHERE type(r) IN $relevant_relation_types
```

### Phase 4: LLMベースの結果フィルタリング

**実装案**:
1. 2-hopで広く取得（現状維持）
2. 取得した関係リストをLLMに渡す
3. 質問との関連度をスコアリング（0-1）
4. Top-K（例: Top 10）のみを返す

```python
def rank_relations_by_relevance(question: str, relations: List[dict]) -> List[dict]:
    """LLMで関係の関連度をスコアリング"""
    prompt = f"""
    質問: {question}

    以下の関係を質問との関連度でスコアリング（0-1）:
    {relations}
    """
    # LLM呼び出し & ソート
```

---

## 検証方法

### テストケース

| 質問 | 期待される関係 | 除外されるべき関係 |
|------|---------------|-------------------|
| 桃太郎を倒したのは誰？ | `鬼 -[DEFEATS]→ 桃太郎`<br>`鬼 -[FIGHTS]→ 桃太郎` | `村 -[LIVES_IN]→ おばあさん`<br>`桃太郎 -[RETURNS_TO]→ 村` |
| おじいさんは誰と住んでいる？ | `おじいさん -[LIVES_IN]→ 村`<br>`おばあさん -[LIVES_IN]→ 村` | `桃太郎 -[FIGHTS]→ 鬼` |
| 桃太郎の仲間は誰？ | `桃太郎 -[BECOMES_COMPANION_OF]→ 犬`<br>`犬 -[MEETS]→ 桃太郎` | `鬼 -[DEFEATS]→ 桃太郎` |

### 検証コマンド（Neo4j Browser）

```cypher
// 変更前の無向クエリ（問題あり）
MATCH (桃太郎 {id: "桃太郎"})
MATCH path = (桃太郎)-[*1..2]-(connected)
RETURN path
LIMIT 20

// 変更後の有向クエリ（修正版）
MATCH (桃太郎 {id: "桃太郎"})
MATCH path = (桃太郎)-[*1..2]->(connected)
RETURN path
LIMIT 20
```

---

## 参考資料

- Neo4j公式ドキュメント: [Variable-length pattern matching](https://neo4j.com/docs/cypher-manual/current/patterns/reference/#varlength-rels)
- 有向 vs 無向パス:
  - `-[*1..2]->` : 有向（順方向のみ）
  - `-[*1..2]-` : 無向（両方向）
  - `<-[*1..2]-` : 有向（逆方向のみ）

---

## ステータス

- [x] Phase 1: 有向トラバーサルへの変更（2025-12-05 実装完了）
- [x] **Phase 1.5: 双方向1-hop直接関係への変更（2025-12-05 実装完了）** ✨
- [ ] Phase 2: 質問タイプの検出
- [ ] Phase 3: 関係タイプフィルタリング
- [x] **Phase 4: LLMベースのリランキング（2025-12-05 実装完了）** ✨

---

## Phase 1.5: 双方向1-hop直接関係への変更 ✅

### 新たに発見された問題

**Phase 1の有向トラバーサル**では、以下の問題が残っていた：

**質問**: 「桃太郎を倒したのは誰？」

**結果（Phase 1後）**:
```
桃太郎 -[SHARES_WITH]→ おじいさん  ✅
おじいさん -[RAISES]→ 桃太郎       ✅
おじいさん -[GOES_TO]→ 山          ❌ 無関係（なぜ含まれる？）
おじいさん -[LIVES_IN]→ 村         ❌ 無関係
```

### 原因

**可変長パス `[*1..2]` の展開ロジック**:

```cypher
WITH relationships(path) AS rels, nodes(path) AS path_nodes
UNWIND range(0, size(rels)-1) AS i
WITH rels[i] AS r, path_nodes[i] AS n, path_nodes[i+1] AS m
```

この処理は**パス内のすべてのエッジを展開**する：

**例**:
- パス: `桃太郎 -[SHARES_WITH]→ おじいさん -[GOES_TO]→ 山`
- 展開結果:
  1. `桃太郎 -[SHARES_WITH]→ おじいさん` ✅
  2. `おじいさん -[GOES_TO]→ 山` ← **中間ノードからの関係も含まれる** ❌

### 解決策

**単一エッジマッチング + 双方向**:

```cypher
# 変更前（可変長パス展開）
MATCH path = (start_node)-[*1..2]->(connected_node)
WITH relationships(path) AS rels, nodes(path) AS path_nodes
UNWIND range(0, size(rels)-1) AS i
WITH rels[i] AS r, path_nodes[i] AS n, path_nodes[i+1] AS m

# 変更後（単一エッジ双方向）
MATCH (start_node)-[r]-(connected_node)  # 1-hop双方向
WITH r, startNode(r) AS actual_start, endNode(r) AS actual_end
RETURN DISTINCT actual_start.id AS start, type(r) AS type, actual_end.id AS end
```

### メリット

1. ✅ **起点ノードと直接接続された関係のみ**
   - 中間ノードからの関係は含まれない
   - `おじいさん -[GOES_TO]→ 山` は除外

2. ✅ **双方向 `-[r]-` で順方向・逆方向両方を取得**
   - `桃太郎 -[FIGHTS]→ 鬼` （順方向）
   - `鬼 -[DEFEATS]→ 桃太郎` （逆方向でもマッチ）

3. ✅ **元の方向性を保持**
   - `startNode(r)` / `endNode(r)` で元の方向を取得
   - グラフの意味が保たれる

### 修正箇所

- [app.py:209-225](app.py#L209-L225) - `restore_from_existing_graph` 内
- [app.py:426-442](app.py#L426-L442) - `create_rag_chain` 内

### 期待される結果

**質問**: 「桃太郎を倒したのは誰？」

**Phase 1.5後の結果**:
```
桃太郎 -[FIGHTS]→ 鬼               ✅ 直接関係
鬼 -[DEFEATS]→ 桃太郎              ✅ 直接関係（逆方向）
桃太郎 -[SHARES_WITH]→ おじいさん  ✅ 直接関係
おじいさん -[RAISES]→ 桃太郎       ✅ 直接関係（逆方向）

おじいさん -[GOES_TO]→ 山          ❌ 除外（桃太郎と直接関係ない）
おじいさん -[LIVES_IN]→ 村         ❌ 除外
村 -[LIVES_IN]→ おばあさん         ❌ 除外
```

### 検証Cypherクエリ

```cypher
// Phase 1.5: 双方向1-hop直接関係
MATCH (桃太郎 {id: "桃太郎"})
MATCH (桃太郎)-[r]-(connected)
WHERE type(r) <> 'MENTIONS'
WITH r, startNode(r) AS s, endNode(r) AS e
RETURN s.id AS start, type(r) AS relation, e.id AS end
LIMIT 30
```

---

## 備考

この問題はGraph RAGの核心的な課題であり、単なるグラフ検索ではなく「**質問の意図を理解した上でのグラフトラバーサル**」が求められる。

- **Phase 1**: 無向→有向で逆向きパスを除外
- **Phase 1.5**: 2-hop可変長→1-hop単一エッジで中間ノード情報を除外

これらの修正により、質問のエンティティに**直接関連する関係のみ**が取得されるようになった。完全な解決にはPhase 2-4の実装が望ましい。

---

## Phase 4: LLMベースのリランキング ✅

### 実装日時
2025-12-05

### 概要

Phase 1.5で中間ノードからの無関係な関係は除外できたが、依然として以下の問題が残っていた：

**質問**: 「桃太郎を倒したのは誰？」

**Phase 1.5の結果**:
```
桃太郎 -[SHARES_WITH]→ おじいさん  ← 質問に関連するが直接的ではない
おじいさん -[RAISES]→ 桃太郎       ← 質問に関連するが直接的ではない
桃太郎 -[FIGHTS]→ 鬼               ← 質問に直接関連 ✅
鬼 -[DEFEATS]→ 桃太郎              ← 質問に直接関連 ✅
```

すべて桃太郎に**直接関連する関係**だが、**質問の意図との関連度**が異なる。

### 実装内容

#### 1. `rank_relations_by_relevance()` 関数の追加

**機能**:
- LLMを使って各関係性を質問との関連度で0-10スコアリング
- スコアでソートして上位top_k件（デフォルト15件）を返す

**実装箇所**:
- [app.py:201-265](app.py#L201-L265) - `restore_from_existing_graph` 内
- [app.py:489-546](app.py#L489-L546) - `build_rag_system` 内

**コード**:
```python
def rank_relations_by_relevance(question: str, relations: list, top_k: int = 15) -> list:
    """LLMを使って関係性の質問への関連度をスコアリング"""
    if not relations:
        return []

    # 関係性リストをテキスト化
    relations_text = "\n".join([
        f"{i+1}. {r['start']} -[{r['type']}]-> {r['end']}"
        for i, r in enumerate(relations)
    ])

    ranking_prompt = f"""以下の質問に対して、各グラフ関係性の関連度を0-10でスコアリングしてください。

【質問】
{question}

【グラフ関係性】
{relations_text}

【指示】
- 各行の番号と関連度スコア（0-10）を「番号:スコア」形式で出力
- 質問に直接関連する関係性は高スコア（8-10）
- 間接的に関連する関係性は中スコア（4-7）
- 無関係な関係性は低スコア（0-3）
- 説明不要、スコアのみ出力

【出力例】
1:9
2:3
3:7

【出力】"""

    try:
        llm = AzureChatOpenAI(...)
        response = llm.invoke(ranking_prompt)

        # スコアをパース
        scores = {}
        for line in response.content.strip().split('\n'):
            if ':' in line:
                try:
                    idx, score = line.split(':')
                    scores[int(idx.strip())] = float(score.strip())
                except:
                    continue

        # スコアでソートして上位top_k件を返す
        ranked_relations = []
        for i, relation in enumerate(relations, 1):
            score = scores.get(i, 0)
            ranked_relations.append((score, relation))

        ranked_relations.sort(reverse=True, key=lambda x: x[0])
        return [rel for score, rel in ranked_relations[:top_k]]

    except Exception as e:
        # LLMリランキング失敗時は元のリストをそのまま返す
        return relations[:top_k]
```

#### 2. `get_graph_context()` への統合

**修正箇所**:
- [app.py:294-296](app.py#L294-L296) - `restore_from_existing_graph` 内
- [app.py:575-577](app.py#L575-L577) - `build_rag_system` 内

**変更内容**:
```python
# 変更前
result = graph.query(query, params={"entities": entities})
return result if result else []

# 変更後
result = graph.query(query, params={"entities": entities})
if result:
    # 3. LLMリランキングで関連度の高い関係性のみに絞る
    result = rank_relations_by_relevance(question, result, top_k=15)
return result if result else []
```

フォールバッククエリにも同様に適用。

### メリット

1. ✅ **質問の意図を考慮した関係のフィルタリング**
   - 「倒したのは誰？」 → `DEFEATS`, `FIGHTS` が高スコア
   - `SHARES_WITH`, `RAISES` は低スコア

2. ✅ **柔軟性**
   - ルールベースでは対応できない複雑な質問にも対応
   - 新しい関係タイプが追加されても自動対応

3. ✅ **コスト効率**
   - 30件から15件への絞り込みのみ
   - 推定コスト: 約$0.0022/クエリ（約0.3円）

4. ✅ **フォールバック対応**
   - LLM呼び出しが失敗しても元の結果を返す
   - システムの堅牢性を維持

### 期待される結果

**質問**: 「桃太郎を倒したのは誰？」

**Phase 4後の結果**（上位5件の例）:
```
鬼 -[DEFEATS]→ 桃太郎              スコア: 10 ✅
桃太郎 -[FIGHTS]→ 鬼               スコア: 9  ✅
桃太郎 -[SURRENDERS_TO]→ 鬼        スコア: 8  ✅
鬼 -[CONFRONTS]→ 桃太郎             スコア: 7  ✅
桃太郎 -[GOES_TO]→ 鬼の島          スコア: 5  (間接的)

桃太郎 -[SHARES_WITH]→ おじいさん  スコア: 2  ❌ 除外
おじいさん -[RAISES]→ 桃太郎       スコア: 2  ❌ 除外
```

### 検証方法

Streamlitアプリで実際に質問を投げて、グラフ可視化タブで結果を確認：

```python
# テストケース
質問1: 「桃太郎を倒したのは誰？」
期待: DEFEATS, FIGHTS 関係が上位に

質問2: 「桃太郎の仲間は誰？」
期待: BECOMES_COMPANION_OF, RECRUITS 関係が上位に

質問3: 「おじいさんは何をした？」
期待: RAISES, FINDS, GOES_TO 関係が上位に
```

### コスト見積もり

**使用モデル**: Azure OpenAI GPT-4
- 入力トークン: 約300トークン（質問 + 30件の関係性）
- 出力トークン: 約60トークン（スコアリスト）

**コスト**:
- 入力: $0.03/1K tokens × 0.3 = $0.0009
- 出力: $0.06/1K tokens × 0.06 = $0.0036
- **合計**: 約$0.0045/クエリ（約0.6円）

1日100クエリでも約60円程度。

### 今後の改善案

**Option A: ハイブリッドアプローチ**
```python
# 1. キーワードで30件→20件に絞る（無料）
# 2. LLMで20件→15件に絞る（コスト半減）
```

**Option B: キャッシュ戦略**
```python
# 同じ質問タイプ（「誰が倒した」等）のスコアをキャッシュ
# 類似質問では再利用
```

---

## まとめ

### 実装完了フェーズ

1. **Phase 1**: 無向→有向トラバーサル（逆向きパス除外）
2. **Phase 1.5**: 可変長パス→1-hop直接関係（中間ノード除外）
3. **Phase 4**: LLMリランキング（質問の意図を考慮）

### 残タスク

- **Phase 2**: 質問タイプ検出（「誰が」「何を」等でホップ数調整）
- **Phase 3**: 関係タイプフィルタリング（キーワードベース）

現状のPhase 1 + 1.5 + 4で、実用的なレベルの関係性抽出精度を達成している。

---

## 課題2: VLLM + LLMGraphTransformer でノード抽出失敗

### 発生日時
2025-01-08

### 問題の詳細

VLLMプロバイダー（gpt-oss-20b）使用時、LLMGraphTransformerでノード・リレーションシップが抽出されない。

**症状**:
- カスタムプロンプト使用時: Nodes=1, Rels=0（ほぼ抽出失敗）
- デフォルトプロンプト使用時: Nodes=7, Rels=13（正常）

### 根本原因

**カスタムプロンプトがLLMGraphTransformerの内部パーサーと競合していた。**

LLMGraphTransformerはデフォルトで独自のプロンプト（ノード・リレーション抽出用）を使用し、その出力形式を内部パーサーが期待している。
カスタムプロンプトを指定すると、LLMの出力形式が内部パーサーの期待する形式と合わなくなり、抽出結果が激減する。

### テスト結果

```
Test 1: no custom prompt          → Nodes=7, Rels=13 ✅
Test 2: custom prompt             → Nodes=1, Rels=0  ❌
Test 3: custom prompt + allowed_* → Nodes=1, Rels=0  ❌
```

### 解決策

**カスタムプロンプトを使わない。**

```python
# VLLMの場合はカスタムプロンプトなし（デフォルトプロンプト使用）
if llm_provider == "vllm":
    llm = create_chat_llm(temperature=0)
    transformer = LLMGraphTransformer(
        llm=llm,
        strict_mode=False,
    )
```

### 修正箇所

- [app.py:1068-1074](app.py#L1068-L1074) - カスタムプロンプト削除

### 学んだこと

1. **LLMGraphTransformerのカスタムプロンプトは危険** - 内部パーサーとの整合性が必要
2. **`ignore_tool_usage=True`は不要だった** - Function Calling問題は別の症状と誤認
3. **テスト結果を信じる** - 複雑な仮説より実測値が正確
4. **シンプルな設定が最強** - デフォルト設定で十分動作する

### 誤った仮説（参考）

当初、以下を疑っていた：
- gpt-oss-20bがFunction Callingストップトークンを認識しない → 暴走
- `ignore_tool_usage=True`でプロンプトベースに切り替えが必要

しかし実際は単に**カスタムプロンプトとパーサーの不整合**が原因だった。
